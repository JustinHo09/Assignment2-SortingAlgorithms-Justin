Problem 1 Mergesort: List1: [1, 2, 3, 6], List2:[-3, 0, 6, 7], and Result: [].
                     Let int i, int j, and int k be integers that refer to the indexes
                     of the List1, List2, and result array respectively, and all of them = 0.
                     The size of result is the combined size of List1 and List2, so 4+4, which
                     is 8.
                     i=0, j=0, k=0.

                Compare List1[i] to List2[j], so List1[0] to List2[0], 1 compared to -3,
                -3 is less than 1 so it is added to Result at index k.
                Result afterwards is: [-3, , , , , , , ].
                Since -3 came from List2, increment j by one, then increment k by one.
                i = 0, j = 1, k = 1.
            After the first iteration Result: [-3, , , , , , , ], i=0, j=1, k=1;

                Compare List1[i] to List2[j], so List1[0] to List2[1], 1 compared to 0,
                0 is less than 1 so it is added to Result at index k.
                Result afterwards is: [-3, 0, , , , , , ]
                Since 0 came from List2, increment j by one, then increment k by one.
                i = 0, j = 2, k = 2.
            After the second iteration Result: [-3, 0, , , , , , ], i=0, j=2,k=2.

                Compare List1[i] to List2[j], so List1[0] to List2[2], 1 compared to 6,
                1 is less than 6 so it is added to result at index k.
                Result afterwards is: [-3, 0, 1, , , , , ].
                Since 1 came from List1, increment i by one, then increment k by one.
                i=1, j=2, k=3.
            After the third iteration Result: [-3, 0, 1, , , , , ], i=1, j=2,k=3.

                Compare List1[i] to List2[j], so List1[1] to List2[2], 2 compared to 6,
                2 is less than 6 so it is added to result at index k.
                Result afterwards is: [-3, 0, 1, 2, , , , ].
                Since 2 came from List1, increment i by one, then increment k by one.
                i=2, j=2, k=4.
            After the fourth iteration Result: [-3, 0, 1, , , , , ], i=2, j=2,k=4.

                Compare List1[i] to List2[j], so List1[2] to List2[2], 3 compared to 6,
                3 is less than 6 so it is added to result at index k.
                Result afterwards is: [-3, 0, 1, 2, 3, , , ].
                Since 3 came from List1, increment i by one, then increment k by one.
                i=3, j=2, k=5.
            After the fifth iteration Result: [-3, 0, 1, 2, 3, , , ], i=3, j=2, k=5.

                Compare List1[i] to List2[j], so List1[3] to List2[2], 6 compared to 6,
                Since 6 is not less than 6, 6 from List2 is added to result at index k.
                Result afterwards is: [-3, 0, 1, 2, 3, 6, , ].
                Since 6 came from List1, increment j by one, then increment k by one.
                i=3, j=3, k=6.
            After the sixth iteration Result: [-3, 0, 1, 2, 3, 6, , ], i=3, j=3, k=6.

                Compare List1[i] to List2[j], so List1[3] to List2[3], 6 compared to 7,
                6 is less than 7 so it is added to result at index k.
                Result afterwards is: [-3, 0, 1, 2, 3, 6, 6, ].
                Since 6 came from List1, increment i by one, then increment k by one.
                i=4, j=3, k=7.
            After the seventh iteration Result: [-3, 0, 1, 2, 3, 6, 6, ], i=4, j=3, k=7.

            Since i = List1.length, 4=4, this loop is exited then since i is not less than
            List1.length and j < List2.length, 3 <4, we enter a while loop to transfer whats
            left in j to result.

            Add List2[j] to Result[k], add 7 to Result at index 7.
            Result: [-3, 0, 1, 2, 3, 6, 6, 7].
            increment j and k by one, j=4 and k=8.
            Since j is no longer less than List2.length, 4, this loop is exited.
            Since i and j are equal to the length of left and right respectively, i=4 and j=4
            List1.length=4 and List2.length=4, 4=4 and 4=4, the loop is exited.
            Merge is done and return result.

            Result: [-3, 0, 1, 2, 3, 6, 6, 7].





Problem 2 Insertion Sort: List: [-21, 5, 7, -10, 61, 8, 3, 10]

                          Assume value at index 0, -21, is already sorted.
                          Let i=1, and i represents out starting index for each iteration
                          Iterate if i< List.length, i<8.
                          i=1, so List[i] = List[1]= 5.
                          Compare 5 and -21, 5 is greater than -21 so no swap is done.
                          Since no swap is done and we assume -21 is sorted than that means
                          -21 and 5 are in sorted order.
                          Increment i by one, i=2
          After first iteration: List: [-21, 5, 7, -10, 61, 8, 3, 10].

                          Compare i and 8, 2 <8, continue loop.
                          i=2, List[i] = List[2] = 7.
                          Compare 7 and 5, 7 is greater than 5 so no swap is done.
                          Since we know -21 and 5 are in sorted order and that 7 does
                          not get swapped with 5, we know it is also in sorted order
                          compared to -21 and 5, which is why is is not compared to -21.
                          Increment i by one, i=3.
          After second iteration: List [-21, 5, 7, -10, 61, 8, 3, 10].

                          Compare i and 8, 3<8, continue loop.
                          i=3, List[i] = List[3] = -10
                          Compare -10 and 7, -10 is less than 7 so swap -10 and 7.
                          After that the list is: [-21, 5, -10, 7, 61, 8, 3, 10].

                          Compare -10 and 5, -10 is less than 5 so swap -10 and 5.
                          After than the list is: [-21, -10, 5, 7, 61, 8, 3, 10].

                          Compare -10 and -21, -10 is greater than -21 so no swap is done.
                          Since -21 is already in sorted position and -10 does not swap with it
                          -10 is now in ordered position.
                          Increment i by one, i=4.
          After third iteration: List [-21, -10, 5, 7, 61, 8, 3, 10]

                          Compare i and 8, 4<8, continue loop.
                          i=4, List[i] = List[4] = 61.
                          Compare 61 and 7, 61 is greater than 7 so no swap is done.
                          Since 7 is already in ordered position compared to the previous elements
                          and no swaps are done with 61, that means 61 is also in ordered position.
                          Increment i by one, i=5.
          After fourth iteration: List [-21, -10, 5, 7, 61, 8, 3, 10]

                          Compare i and 8, 5<8 continue loop.
                          i=5, List[i] = List[5] =8.
                          Compare 8 and 61, 8 is less than 61 so swap 8 and 61.
                          After that the list is: [-21, -10, 5, 7, 8, 61, 3, 10].

                          Compare 8 and 7, 8 is greater than 7 so no swap is done.
                          Since 7 is already in ordered position compared to the previous elements
                          and no swap is done with 8, that means 8 is in ordered position.
                          Increment i by one, i=6.
          After fifth iteration: List [-21, -10, 5, 7, 8, 61, 3, 10]

                          Compare i and 8, 6<8 continue loop.
                          i=6, List[i] = List[6] = 3.
                          Compare 3 and 61, 3 is less than 61 so swap 3 and 61.
                          After that the list is: [-21, -10, 5, 7, 8, 3, 61, 10]

                          Compare 3 and 8, 3 is less than 8 so swap 3 and 8.
                          After that the list is: [-21, -10, 5, 7, 3, 8, 61, 10]

                          Compare 3 and 7, 3 is less than 7 so swap 3 and 7.
                          After that the list is: [-21, -10, 5, 3, 7, 8, 61, 10].

                          Compare 3 and 5, 3 is less than 5 so swap 3 and 5.
                          After that the list is: [-21, -10, 3, 5, 7, 8, 61, 10].

                          Compare 3 and -10, 3 is greater than -10 so no swap is done.
                          Since -10 is already in ordered position compared to the previous
                          elements, 3 is also now in ordered position.
                          Increment i by one, i=7.
          After sixth iteration: List [-21, -10, 3, 5, 7, 8, 61, 10].

                          Compare i and 8, 7<8 continue loop.
                          i=7, List[i] = List[7] = 10.
                          Compare 10 and 61, 10 is less than 61, so swap 10 and 61.
                          After that the list is: [-21, -10, 3, 5, 7, 8, 10, 61]

                          Compare 10 and 8, 10 is greater than 8 so no swap.
                          Since 8 is already in ordered position compared to the previous elements
                          that means 10 is now also in ordered position.
                          Increment i by one, i=8.
          After seventh iteration: List [-21, -10, 3, 5, 7, 8, 10, 61]

                          Compare i and 8, 8<8 not true so don't loop.
          Return List.
          The list is fully sorted.




Problem 3 Quicksort: List: [-5, 4, 2, 619, 11, 5, 620, -3]
            low = 0, high = List.length-1, median = high+low/2 = 7+0/2 = 3 (integer division)
            pivot = median of List[low], List[median], List[high] = median of -5, 619, -3.
            pivot = -3.
            swap pivot with last element so List: [-5, 4, 2, 619, 11, 5, 620, -3]
            two int i and j to look at indexes in the list.
            i=low and j=high-1, so i=0 and j=6.

            loop until i >j or List[i] >pivot
            compare List[i] to pivot to see if its greater,List[0]= -5 < -3, its less than pivot so
            increment i and try again, now i=1.

            compare List[i] to pivot,List[1]= 4 > -3, stop looping, i=1.

            loop until i>j or List[j] < pivot
            compare List[j] to pivot to see if its less, 620 > -3, its greater than pivot
            so decrement j and try again, now j=5.

            compare List[j] to pivot,List[5]=5> -3, its greater so decrement j and try again, now j=4.

            compare List[j] to pivot,List[4]=11>-3, its greater so decrement j and try again, now j=3.

            compare List[j] to pivot,List[3]=619 > -3, its greater so decrement j and try again, now j=2.

            compare List[j] to pivot,List[2]=2 >-3, its greater so decrement j and try again, now j=1.

            compare List[j] to pivot,List[1]=4 > -3, its greater so decrement j and try again, now j=0;

            since j < k stop the loops.
            since i > j don't swap element at i with element at j.
            swap element at i with pivot, so List[i] and pivot, swap 4 and -3.
            List: [-5, -3, 2, 619, 11, 5, 620, 4]
            pivotIndex = 1;
            Since -3 was the pivot -3 is sorted.
    After 1st call to pivot, List: [-5, -3, 2, 619, 11, 5, 620, 4].

            recursive call on left partition, low = 0, high = pivotIndex-1 = 0.
                high <= low, 0<=0, return so this recursive call ends meaning -5 is sorted.
                List: [-5, -3, 2, 619, 11, 5, 620, 4]


            recursive call on right partition, low = pivotIndex+1 =2, high = List.length-1 =7.
                median = high+low/2 = 7+2/2 = 4 (integer division).
                pivot = median of List[low], List[median], List[high] = median of 2, 11, 4 = 4.
                swap pivot and last element, so pivot and high, swap 4 and 4.
                List: [-5, -3, 2, 619, 11, 5, 620, 4].
                i=low, j=high-1, i=2, j=6.

                loop until i >j or List[i] >pivot
                compare List[i] to pivot, List[2]= 2 < 4 so increment i and try again, now i=3.

                compare List[i] to pivot, List[3]=619 > 4 so stop looping, i=3.

                loop until i>j or List[j] < pivot
                compare List[j] to pivot, List[6]=620 >4, decrement j and try again, now j=5.

                compare List[j] to pivot, List[5]=5 >4, decrement j and try again, now j=4.

                compare List[j] to pivot, List[4]=11 >4, decrement j and try again, now j=3.

                compare List[j] to pivot, List[3]=619 >4, decrement j and try again, now j=2.

                since i >j, 3>2, stop the loop.
                since i>j don't swap element at i and j.
                swap element at i with pivot,so List[i] and pivot, swap 619 and 4.
                List: [-5, -3, 2, 4, 11, 5, 620, 619]
                pivotIndex = 3;
                Since 4 was the pivot 4 is sorted.
    After 1st set of recursive calls are done List: [-5, -3, 2, 4, 11, 5, 620, 619]

                recursive call on left side of the first right partition:
                low = 2, high = pivotIndex-1 = 3-1=2.
                since high <= low, return so this recursive call is done meaning 2 is sorted.
                List: [-5, -3, 2, 4, 11, 5, 620, 619]

                recursive call on right side of the first right partition:
                low = pivotIndex+1 = 3+1 =4, high = List.length-1=7, median = 7+4/2 = 5 (int division)
                pivot = median of List[low],List[median],List[high] = median of 11, 5, 619 = 11
                swap pivot and last element, pivot and high, 11 and 619.
                List: [-5, -3, 2, 4, 619, 5, 620, 11].
                i=low, j=high-1, i=4, j=7-1=6

                Loop until i>j or List[i] > pivot
                compare List[i] and pivot,List[4] = 619 > 11, so stop looping, i=4

                Loop until i>j or List[j] < pivot
                compare List[j] and pivot,List[6] = 620 > 11, decrement j and try again, now j=5.

                compare List[j] and pivot, List[5] = 5 < 11, so stop looping, j=5;

                since i<=j, swap List[i] and List[j], swap 619 and 5.
                List: [-5, -3, 2, 4, 5, 619, 620, 11].

                run the loops again, i=4, j=5.

                Loop until i>j or List[i] > pivot.
                compare List[i] and pivot, List[4] = 5 < 11, increment i and try again, now i = 5.

                compare List[i] and pivot, List[5] = 619 > 11, so stop looking i=5.

                Loop until i>j or List[j] < pivot.
                compare List[j] and pivot, List[5] = 619 > 11, so decrement j and try again, j = 4.
                Since i >j, 5 >4 stop the loop, j=4.

                Since i>j don't swap elements at index i and j.

                swap element at i with pivot, swap List[i] and pivot, swap 619 and 11.
                List: [-5, -3, 2, 4, 5, 11, 620, 619].
                pivotIndex = 5;
                Since 11 was the pivot 11 is sorted.
    After second set of recursive calls List: [-5, -3, 2, 4, 5, 11, 620, 619].

                recursive call on left side of previous right partition:
                low = 4, high = pivotIndex-1= 5-1 =4.
                Since high <= low, 4<=4, return so this recursive call is done and 5 is sorted.

                recursive call on right side of the previous right partition:
                low = pivotIndex+1 = 5+1 = 6, high = List.length-1 = 7,
                median = high+low/2 = 7+6/2 = 6 (int division).
                pivot = median of(List[low], List[median], List[high] = 620, 620, 619 = 620
                Swap pivot and last element, swap pivot and List[high], swap 620 and 619.
                List: [-5, -3, 2, 4, 5, 11, 619, 620].
                i = low, j=high-1, i=6, j = 7-1 = 6.

                Loop until i > j or List[i] > pivot:
                compare List[i] and pivot, List[6] =619 = 619, increment i and try again, now i=7.
                i > j, 7>6 so stop loop, i=7;

                Loop until i>j or List[j] < pivot:
                since i>j 7>6 loop is not taken, j=6;

                i>j so don't swap elements at index i and j.

                swap element at index i with pivot, swap List[7] and pivot, swap 620 and 620.
                List: [-5, -3, 2, 4, 5, 11, 619, 620].
                pivotIndex = 7
                Since 620 is the pivot 620 is sorted.
    After third set of recursive calls List: [-5, -3, 2, 4, 5, 11, 619, 620].

                recursive call on left side of previous right partition:
                low = 6, high = pivotIndex-1 = 7-1=6.
                Since high <= low, 6 <=6, return so this recursive call is done an 619 is sorted.

                recursive call on the right side of the previous right partition:
                low = pivotIndex+1 = 7+1 =8, high = List.length-1=7.
                Since high <= low, 8<=7, return so this recursive call is done.
    After the fourth set of recursive calls List: [-5, -3, 2, 4, 5, 11, 619, 620].

    All recursive calls have hit the base case and returned, so sorting is done and
    List: [-5, -3, 2, 4, 5, 11, 619, 620].



Problem 4 Shell Sort: List: [5, 10, 60, 0, -1, 34, 6, 10]

            Gap= List.length /2, which is 8/2 = 4.
            So this means there are 4 interleaves this iteration made from List.
            Interleaves are not separate lists just the sections of the list that will be
            evaluated and sorted like its own.

            i =0, i is the starting index, and stop incrementing i when i>=gap.
            Interleave1 = List[i] and List[i+gap] = List[0] and List[0+4]=List[4], so 5 and -1
            Increment i by one, i=1.
            Interleave2 = List[i] and List[i+gap] = List[1] and List[1+4]=List[5], so 10 and 34.
            Increment i by one, i=2.
            Interleave3 = List[i] and List[i+gap] = List[2] and List[2+4]=List[6], so 60 and 6.
            Increment i by one, i=3.
            Interleave4 = List[i] and List[i+gap] = List[3] and List[3+4]=List[7], so 0 and 10.
            Increment i by one, i=4.
            i >= gap, 4>=4 so stop incrementing i and interleaves are done.

            Interleave1: [5,-1], Interleave2: [10,34], Interleave3: [60,6] and Interleave4: [0,10].
            Each interleave contains one element and every element the gap distance away from it.

            Compare 5 and -1 in Interleave1, 5 is greater than -1, so swap 5 and -1.
            After that Interleave1: [-1,5]
            List: [-1, 10, 60, 0, 5, 34, 6, 10].

            Compare 10 and 34 in Interleave2, 34 is greater than 10, so no swap occurs.
            List: [-1, 10, 60, 0, 5, 34, 6, 10].

            Compare 60 and 6 in Interleave3, 6 is less than 60, so swap 6 and 60.
            After that Interleave3: [6, 60]
            List: [-1, 10, 6, 0, 5, 34, 60, 10].

            Compare 0 and 10 in Interleave3, 10 is greater than 0 so no swap occurs.
            List: [-1, 10, 6, 0, 5, 34, 60, 10].
        After one iteration List: [-1, 10, 6, 0, 5, 34, 60, 10]

            Gap= Gap/2 so 4/2 = 2
            So there will be 2 interleaves.
            i = 0 again, i is the starting index, and stop incrementing i when i >= gap.
            Interleave1: List[i], List[i+gap], List[i+gap+gap], List[i+gap+gap+gap] =
                         List[0], List[2], List[4], List[6] = -1,6,5,60.
                         increment i by one, i=1.

            Interleave2: List[i], List[i+gap], List[i+gap+gap], List[i+gap+gap+gap] =
                         List[1], List[3], List[5], List[7] = 10, 0, 34, 10.
                         increment i by one, i=2.
            i >= gap, 2 >= 2  so stop incrementing i and interleaves are done.

            Interleave1: [-1, 6, 5, 60] and Interleave2: [10, 0, 34, 10]

            Compare -1 and 6 in Interleave1, 6 is greater than -1 so no swap.
            List: [-1, 10, 6, 0, 5, 34, 60, 10].

            Compare 6 and 5 in Interleave1, 5 is less than 6 so swap 5 and 6.
            After that Interleave1: [-1, 5, 6, 60]
            List: [-1, 10, 5, 0, 6, 34, 60, 10].

            Compare -1 and 5 in Interleave1, 5 is greater than -1 so no swap.
            List: [-1, 10, 5, 0, 6, 34, 60, 10].

            Compare 6 and 60 in Interleave1, 60 is greater than 6 so no swap.
            List: [-1, 10, 5, 0, 6, 34, 60, 10].

            Compare 10 and 0 in Interleave2, 0 is less than 10 so swap 0 and 10.
            After that Interleave2: [0, 10, 34, 10].
            List: [-1, 0, 5, 10, 6, 34, 60, 10].

            Compare 10, the first one and 34 in Interleave2, 34 is greater than 10 so no swap.
            List: [-1, 0, 5, 10, 6, 34, 60, 10].

            Compare 34 and 10, the last one, 10 is less than 34 so swap 10 and 34.
            After that Interleave2: [0, 10, 10, 34].
            List: [-1, 0, 5, 10, 6, 10, 60, 34].

            Compare 10 and 10, 10 is not less than 10, so no swap.
            List: [-1, 0, 5, 10, 6, 10, 60, 34].
        After second iteration List: [-1, 0, 5, 10, 6, 10, 60, 34]

            Gap = Gap/2 so 2/2=1.

            Compare 0 and -1, 0 is greater than -1 so no swap.
            List: [-1, 0, 5, 10, 6, 10, 60, 34].

            Compare 5 and 0, 5 is greater than 0 so no swap.
            List: [-1, 0, 5, 10, 6, 10, 60, 34].

            Compare 10 and 5, 10 is greater than 5 so no swap.
            List: [-1, 0, 5, 10, 6, 10, 60, 34].

            Compare 6 and 10, 6 is less than 10 so swap 6 and 10.
            List: [-1, 0, 5, 6, 10, 10, 60, 34].

            Compare 5 and 5, 6 is greater than 5 so no swap.
            List: [-1, 0, 5, 6, 10, 10, 60, 34].

            Compare 10 and 10, 10 is not less than 10 so no swap.
            List: [-1, 0, 5, 6, 10, 10, 60, 34].

            Compare 60 and 10, 60 is greater than 10 so no swap.
            List: [-1, 0, 5, 6, 10, 10, 60, 34].

            Compare 34 and 60, 34 is less than 60 so swap 34 and 60.
            List: [-1, 0, 5, 6, 10, 10, 34, 60].
            Compare 34 and 10, 34 is greater than 10 so no swap.
            List: [-1, 0, 5, 6, 10, 10, 34, 60].
        After third iteration List: [-1, 0, 5, 6, 10, 10, 34, 60].

        Return list.
        The list is fully sorted.

Problem 5:

        My ranking of the sorting algorithms is:
        (1 fastest to 2 slowest)
        1. Merge Sort
        2. Quick sort, Shell sort, Selection Sort, Insertion Sort, and Bubble Sort.(tied)


        The reason quick, shell, selection, insertion, and bubble sort are all tied is because
        they all have the same worst time complexity of O(n^2). Since they all have the same
        worst case time complexity, in theory they should all have a very similar runtime
        to each other which is why they are all tied. Merge sort is not with the other because
        its worst case time complexity is O(n log n). In terms of asymptotic growth, O(n^2)
        grows much faster than O(n log n), so most the time O(n^2) will be greater than O(nlogn).
        In the case of runtime, since O(n^2) grows faster than O(nlogn), this means that the
        runtime of algorithms with O(n^2) complexity will be high than that of O(nlogn).
        Since O(n^2) would have a longer runtime than O(nlogn), merge sort will be faster than
        the other sorting algorithms, which is why its ranked first above thee rest.



