Problem 1 Mergesort: List1: [1, 2, 3, 6], List2:[-3, 0, 6, 7], and Result: [].
                     Let int i, int j, and int k be integers that refer to the indexes
                     of the List1, List2, and result array respectively, and all of them = 0.
                     The size of result is the combined size of List1 and List2, so 4+4, which
                     is 8.

                Compare List1[i] to List2[j], so List1[0] to List2[0], 1 compared to -3,
                -3 is less than 1 so it is added to Result at index k.
                Result afterwards is: [-3, , , , , , , ].
                Since -3 came from List2, increment j by one, then increment k by one.
                i = 0, j = 1, k = 1.
            After the first iteration Result: [-3, , , , , , , ], i=0, j=1, k=1;

                Compare List1[i] to List2[j], so List1[0] to List2[i], 1 compared to 0,
                0 is less than 1 so it is added to Result at index k.
                Result afterwards is: [-3, 0, , , , , , ]
                Since 0 came from List2, increment j by one, then increment k by one.
                i = 0, j = 2, k = 2.
            After the second iteration Result: [-3, 0, , , , , , ], i=0, j=2,k=2.

                Compare List1[i] to List2[j], so List1[0] to List2[2], 1 compared to 6,
                1 is less than 6 so it is added to result at index k.
                Result afterwards is: [-3, 0, 1, , , , , ].
                Since 1 came from List1, increment i by one, then increment k by one.
                i=1, j=2, k=3.
            After the third iteration Result: [-3, 0, 1, , , , , ], i=1, j=2,k=3.

                Compare List1[i] to List2[j], so List1[1] to List2[2], 2 compared to 6,
                2 is less than 6 so it is added to result at index k.
                Result afterwards is: [-3, 0, 1, 2, , , , ].
                Since 2 came from List1, increment i by one, then increment k by one.
                i=2, j=2, k=4.
            After the fourth iteration Result: [-3, 0, 1, , , , , ], i=2, j=2,k=3.

                Compare List1[i] to List1[j], so List1[2] to List2[2], 3 compared to 6,
                3 is less than 6 so it is added to result at index k.
                Result afterwards is: [-3, 0, 1, 2, 3, , , ].
                Since 3 came from List1, increment i by one, then increment k by one.
                i=3, j=2, k=5.
            After the fifth iteration Result: [-3, 0, 1, 2, 3, , , ], i=3, j=2, k=5.

                Compare List1[i] to List2[j], so List1[3] to List2[2], 6 compared to 6,
                Since 6 is not less than 6, 6 from List2 is added to result at index k.
                Result afterwards is: [-3, 0, 1, 2, 3, 6, , ].
                Since 6 came from List1, increment j by one, then increment k by one.
                i=3, j=3, k=6.
            After the sixth iteration Result: [-3, 0, 1, 2, 3, 6, , ].

                Compare List1[i] to List2[j], so List1[3] to List2[3], 6 compared to 7,
                6 is less than 7 so it is added to result at index k.
                Result afterwards is: [-3, 0, 1, 2, 3, 6, 6, ].
                Since 6 came from List1, increment i by one, then increment k by one.
                i=4, j=3, k=7.
            After the seventh iteration Result: [-3, 0, 1, 2, 3, 6, 6, ].

            Since i = List1.length, 4=4, this loop is exited then since i is not less than
            List1.length and j < List2.length, 3 <4, we enter a while loop to transfer whats
            left in j to result.

            Add List2[j] to Result[k], add 7 to Result at index 8.
            Result: [-3, 0, 1, 2, 3, 6, 6, 7].
            increment j and k by one, j=4 and k=8.
            Since j is no longer less than List2.length, 4, this loop is exited.

            Merge is done and return result.

            Result: [-3, 0, 1, 2, 3, 6, 6, 7].





Problem 2 Insertion Sort: List: [-21, 5, 7, -10, 61, 8, 3, 10]

                          Assume value at index 0, -21, is already sorted.
                          Compare 5 and -21, 5 is greater than -21 so no swap is done.
                          Since no swap is done and we assume -21 is sorted than that means
                          -21 and 5 are in sorted order.
          After first iteration: List: [-21, 5, 7, -10, 61, 8, 3, 10].


                          Compare 7 and 5, 7 is greater than 5 so no swap is done.
                          Since we know -21 and 5 are in sorted order and that 7 does
                          not get swapped with 5, we know it is also in sorted order
                          compared to -21 and 5, which is why is is not compared to -21.
          After second iteration: List [-21, 5, 7, -10, 61, 8, 3, 10].

                          Compare -10 and 7, -10 is less than 7 so swap -10 and 7.
                          After that the list is: [-21, 5, -10, 7, 61, 8, 3, 10].

                          Compare -10 and 5, -10 is less than 5 so swap -10 and 5.
                          After than the list is: [-21, -10, 5, 7, 61, 8, 3, 10].

                          Compare -10 and -21, -10 is greater than -21 so no swap is done.
                          Since -21 is already in sorted position and -10 does not swap with it
                          -10 is now in ordered position.
          After third iteration: List [-21, -10, 5, 7, 61, 8, 3, 10]

                          Compare 61 and 7, 61 is greater than 7 so no swap is done.
                          Since 7 is already in ordered position compared to the previous elements
                          and no swaps are done with 61, that means 61 is also in ordered position.
          After fourth iteration: List [-21, -10, 5, 7, 61, 8, 3, 10]

                          Compare 8 and 61, 8 is less than 61 so swap 8 and 61.
                          After that the list is: [-21, -10, 5, 7, 8, 61, 3, 10].

                          Compare 8 and 7, 8 is greater than 7 so no swap is done.
                          Since 7 is already in ordered position compared to the previous elements
                          and no swap is done with 8, that means 8 is in ordered position.
          After fifth iteration: List [-21, -10, 5, 7, 8, 61, 3, 10]

                          Compare 3 and 61, 3 is less than 61 so swap 3 and 61.
                          After that the list is: [-21, -10, 5, 7, 8, 3, 61, 10]

                          Compare 3 and 8, 3 is less than 8 so swap 3 and 8.
                          After that the list is: [-21, -10, 5, 7, 3, 8, 61, 10]

                          Compare 3 and 7, 3 is less than 7 so swap 3 and 7.
                          After that the list is: [-21, -10, 5, 3, 7, 8, 61, 10].

                          Compare 3 and 5, 3 is less than 5 so swap 3 and 5.
                          After that the list is: [-21, -10, 3, 5, 7, 8, 61, 10].

                          Compare 3 and -10, 3 is greater than -10 so no swap is done.
                          Since -10 is already in ordered position compared to the previous
                          elements, 3 is also now in ordered position.
          After sixth iteration: List [-21, -10, 3, 5, 7, 8, 61, 10].

                          Compare 10 and 61, 10 is less than 61, so swap 10 and 61.
                          After that the list is: [-21, -10, 3, 5, 7, 8, 10, 61]

                          Compare 10 and 8, 10 is greater than 8 so no swap.
                          Since 8 is already in ordered position compared to the previous elements
                          that means 10 is now also in ordered position.
          After seventh iteration: List [-21, -10, 3, 5, 7, 8, 10, 61]

                          Compare 61 and 10, 61 is greater than 10 so no swap.
                          Since 10 is already in sorted position compared to the previous
                          elements, that means 61 is now also in ordered position.
          After eighth iteration: List [-21, -10, 3, 5, 7, 8, 10, 61]
          The list is fully sorted.

Problem 3 Quicksort: List: [-5, 4, 2, 619, 11, 5, 620, -3]
            low = 0, high = List.length-1, median = high+low/2 = 7+0/2 = 3 (integer division)
            pivot = median of List[low], List[median], List[high] = median of -5, 619, -3.
            pivot = -3.
            swap pivot with last element so List: [-5, 4, 2, 619, 11, 5, 620, -3]
            two int i and j to look at indexes in the list.
            i=low and j=high-1, so i=0 and j=6.

            loop until i >j or List[i] >pivot
            compare List[i] to pivot to see if its greater,List[0]= -5 < -3, its less than pivot so
            increment i and try again, now i=1.

            compare List[i] to pivot,List[1]= 4 > -3, stop looping, i=1.

            loop until i>j or List[j] < pivot
            compare List[j] to pivot to see if its less, 620 > -3, its greater than pivot
            so decrement j and try again, now j=5.

            compare List[j] to pivot,List[5]=5> -3, its greater so decrement j and try again, now j=4.

            compare List[j] to pivot,List[4]=11>-3, its greater so decrement j and try again, now j=3.

            compare List[j] to pivot,List[3]=619 > -3, its greater so decrement j and try again, now j=2.

            compare List[j] to pivot,List[2]=2 >-3, its greater so decrement j and try again, now j=1.

            compare List[j] to pivot,List[1]=4 > -3, its greater so decrement j and try again, now j=0;

            since j < k stop the loops.
            since i > j don't swap element at i with element at j.
            swap element at i with pivot, so List[i] and pivot, swap 4 and -3.
            List: [-5, -3, 2, 619, 11, 5, 620, 4]
            pivotIndex = 1;
            Since 3 was the pivot 3 is sorted.
    After 1st call to pivot, List: [-5, -3, 2, 619, 11, 5, 620, 4].

            recursive call on left partition, low = 0, high = pivotIndex-1 = 0.
                high <= low, 0<=0, return so this recursive call ends meaning -5 is sorted.
                List: [-5, -3, 2, 619, 11, 5, 620, 4]


            recursive call on right partition, low = pivotIndex+1 =2, high = List.length-1 =7.
                median = high+low/2 = 7+2/2 = 4 (integer division).
                pivot = median of List[low], List[median], List[high] = median of 2, 11, 4 = 4.
                swap pivot and last element, so pivot and high, swap 4 and 4.
                List: [-5, -3, 2, 619, 11, 5, 620, 4].
                i=low, j=high-1, i=2, j=6.

                loop until i >j or List[i] >pivot
                compare List[i] to pivot, List[2]= 2 < 4 so increment i and try again, now i=3.

                compare List[i] to pivot, List[3]=619 > 4 so stop looping, i=3.

                loop until i>j or List[j] < pivot
                compare List[j] to pivot, List[6]=620 >4, decrement j and try again, now j=5.

                compare List[j] to pivot, List[5]=5 >4, decrement j and try again, now j=4.

                compare List[j] to pivot, List[4]=11 >4, decrement j and try again, now j=3.

                compare List[j] to pivot, List[3]=619 >4, decrement j and try again, now j=2.

                since i >j, 3>2, stop the loop.
                since i>j don't swap element at i and j.
                swap element at i with pivot,so List[i] and pivot, swap 619 and 4.
                List: [-5, -3, 2, 4, 11, 5, 620, 619]
                pivotIndex = 3;
                Since 4 was the pivot 4 is sorted.
    After 1st set of recursive calls are done List: [-5, -3, 2, 4, 11, 5, 620, 619]

                recursive call on left side of the first right partition:
                low = 2, high = pivotIndex-1 = 3-1=2.
                since high <= low, return so this recursive call is done meaning 2 is sorted.
                List: [-5, -3, 2, 4, 11, 5, 620, 619]

                recursive call on right side of the first right partition:
                low = pivotIndex+1 = 3+1 =4, high = List.length-1=7, median = 7+4/2 = 5 (int division)
                pivot = median of List[low],List[median],List[high] = median of 11, 5, 619 = 11
                swap pivot and last element, pivot and high, 11 and 619.
                List: [-5, -3, 2, 4, 619, 5, 620, 11].
                i=low, j=high-1, i=4, j=7-1=6

                Loop until i>j or List[i] > pivot
                compare List[i] and pivot,List[4] = 619 > 11, so stop looping, i=4

                Loop until i>j or List[j] < pivot
                compare List[j] and pivot,List[6] = 620 > 11, decrement j and try again, now j=5.

                compare List[j] and pivot, List[5] = 5 < 11, so stop looping, j=5;

                since i<=j, swap List[i] and List[j], swap 619 and 5.
                List: [-5, -3, 2, 4, 5, 619, 620, 11].

                run the loops again, i=4, j=5.

                Loop until i>j or List[i] > pivot.
                compare List[i] and pivot, List[4] = 5 < 11, increment i and try again, now i = 5.

                compare List[i] and pivot, List[5] = 619 > 11, so stop looking i=5.

                Loop until i>j or List[j] < pivot.
                compare List[j] and pivot, List[5] = 619 > 11, so decrement j and try again, j = 4.
                Since i >j, 5 >4 stop the loop, j=4.

                Since i>j don't swap elements at index i and j.

                swap element at i with pivot, swap List[i] and pivot, swap 619 and 11.
                List: [-5, -3, 2, 4, 5, 11, 620, 619].
                pivotIndex = 5;
                Since 11 was the pivot 11 is sorted.
    After second set of recursive calls List: [-5, -3, 2, 4, 5, 11, 620, 619].

                recursive call on left side of previous right partition:
                low = 4, high = pivotIndex-1= 5-1 =4.
                Since high <= low, 4<=4, return so this recursive call is done and 5 is sorted.

                recursive call on right side of the previous right partition:
                low = pivotIndex+1 = 5+1 = 6, high = List.length-1 = 7,
                median = high+low/2 = 7+6/2 = 6 (int division).
                pivot = median of(List[low], List[median], List[high] = 620, 620, 619 = 620
                Swap pivot and last element, swap pivot and List[high], swap 620 and 619.
                List: [-5, -3, 2, 4, 5, 11, 619, 620].
                i = low, j=high-1, i=6, j = 7-1 = 6.

                Loop until i > j or List[i] > pivot:
                compare List[i] and pivot, List[6] =619 = 619, increment i and try again, now i=7.
                i > j, 7>6 so stop loop, i=7;

                Loop until i>j or List[j] < pivot:
                since i>j 7>6 loop is not taken, j=6;

                i>j so don't swap elements at index i and j.

                swap element at index i with pivot, swap List[7] and pivot, swap 620 and 620.
                List: [-5, -3, 2, 4, 5, 11, 619, 620].
                pivotIndex = 7
                Since 620 is the pivot 620 is sorted.
    After third set of recursive calls List: [-5, -3, 2, 4, 5, 11, 619, 620].

                recursive call on left side of previous right partition:
                low = 6, high = pivotIndex-1 = 7-1=6.
                Since high <= low, 6 <=6, return so this recursive call is done an 619 is sorted.

                recursive call on the right side of the previous right partition:
                low = pivotIndex+1 = 7+1 =8, high = List.length-1=7.
                Since high <= low, 8<=7, return so this recursive call is done.
    After the fourth set of recursive calls List: [-5, -3, 2, 4, 5, 11, 619, 620].

    All recursive calls have hit the base case and returned, so sorting is done and
    List: [-5, -3, 2, 4, 5, 11, 619, 620].



Problem 4 Shell Sort: List: [5, 10, 60, 0, -1, 34, 6, 10]

            Gap= List.length /2, which is 8/2 = 4.
            So this means there are 4 interleaves this iteration made from List.
            Interleaves are not separate lists just the sections of the list that will be
            evaluated and sorted like its own.

            Interleave1: [5,-1], Interleave2: [10,34], Interleave3: [60,6] and Interleave4: [0,10].
            Each interleave contains one element and every element the gap distance away from it.

            Compare 5 and -1 in Interleave1, 5 is less than -1, so swap 5 and -1.
            After that Interleave1: [-1,5]
            List: [-1, 10, 60, 0, -1, 34, 6, 10].

            Compare 10 and 34 in Interleave2, 34 is greater than 10, so no swap occurs.
            List: [-1, 10, 60, 0, -1, 34, 6, 10].

            Compare 60 and 6 in Interleave3, 6 is less than 60, so swap 6 and 60.
            After that Interleave3: [6, 60]
            List: [-1, 10, 6, 0, -1, 34, 60, 10].

            Compare 0 and 10 in Interleave3, 10 is greater than 0 so no swap occurs.
            List: [-1, 10, 6, 0, -1, 34, 60, 10].
        After one iteration List: [-1, 10, 6, 0, 5, 34, 60, 10]

            Gap= Gap/2 so 4/2 = 2
            So there will be 2 interleaves.
            Interleave1: [-1, 6, 5, 60] and Interleave2: [10, 0, 34, 10]

            Compare -1 and 6 in Interleave1, 6 is greater than -1 so no swap.
            List: [-1, 10, 6, 0, 5, 34, 60, 10].

            Compare 6 and 5 in Interleave1, 5 is less than 6 so swap 5 and 6.
            After that Interleave1: [-1, 5, 6, 60]
            List: [-1, 10, 5, 0, 6, 34, 60, 10].

            Compare -1 and 5 in Interleave1, 5 is greater than -1 so no swap.
            List: [-1, 10, 5, 0, 6, 34, 60, 10].

            Compare 6 and 60 in Interleave1, 60 is greater than 6 so no swap.
            List: [-1, 10, 5, 0, 6, 34, 60, 10].

            Compare 10 and 0 in Interleave2, 0 is less than 10 so swap 0 and 10.
            After that Interleave2: [0, 10, 34, 10].
            List: [-1, 0, 5, 10, 6, 34, 60, 10].

            Compare 10, the first one and 34 in Interleave2, 34 is greater than 10 so no swap.
            List: [-1, 0, 5, 10, 6, 34, 60, 10].

            Compare 34 and 10, the last one, 10 is less than 34 so swap 10 and 34.
            After that Interleave2: [0, 10, 10, 34].
            List: [-1, 0, 5, 10, 6, 10, 60, 34].

            Compare 10 and 10, 10 is not less than 10, so no swap.
            List: [-1, 0, 5, 10, 6, 10, 60, 34].
        After second iteration List: [-1, 0, 6, 10, 5, 10, 60, 34]

            Gap = Gap/2 so 2/2=1.

            Compare 0 and -1, 0 is greater than -1 so no swap.
            List: [-1, 0, 6, 10, 5, 10, 60, 34].

            Compare 6 and 0, 6 is greater than 0 so no swap.
            List: [-1, 0, 6, 10, 5, 10, 60, 34].

            Compare 10 and 6, 10 is greater than 6 so no swap.
            List: [-1, 0, 6, 10, 5, 10, 60, 34].

            Compare 5 and 10, 5 is less than 10 so swap 5 and 10.
            List after: [-1, 0, 6, 5, 10, 10, 60, 34].

            Compare 5 and 6, 5 is less than 6 so swap 5 and 6.
            List after: [-1, 0, 5, 6, 10, 10, 60, 34].

            Compare 5 and 0, 5 is greater than 0 so no swap.

            Compare 10 and 10, 10 is not less than 10 so no swap.

            Compare 60 and 10, 60 is greater than 10 so no swap.

            Compare 34 and 60, 34 is less than 60 so swap 34 and 60.
            List after: [-1, 0, 5, 6, 10, 10, 34, 60]
            Compare 34 and 10, 34 is greater than 10 so no swap.

            Compare 60 and 34, 60 is greater than 34 so no swap.
        After third iteration List: [-1, 0, 5, 6, 10, 10, 34, 60]
        The list if fully sorted.

Problem 5:

        My ranking of the sorting algorithms is:
        (1 fastest to 5 slowest)
        1. Merge Sort
        2. Quick Sort
        3. Shell Sort
        4. Insertion Sort and Bubble Sort tied
        5. Selection sort

        The reason I ranked selection sort last is because no matter the input size
        or order it will always do two passes of the array so it will always be O(n^2).
        So since it will always be O(n^2) no matter what the array is I think it will consistently
        have the longest runtime compared to all the other sorting methods. Then the reason I
        predicted a tie for insertion and bubble sort is because both of them have a worst
        case time complexity of O(n^2), and a best case time complexity of O(n). Since, their
        worst and best case time complexities are the same, I think that insertion and bubble
        sort will have very similar run times to each other, which is why I believe that both
        of them are tied on the ranking. The reason I think that both of them are ranked higher
        than selection sort is because in their best case they are O(n), which is faster compared
        to selection sort's best case of O(n^2). So, with possibility of the best case in mind,
        I think that insertion and bubble sort will do better than selection sort. Even so the
        best case is not always likely to happen, compared to the other algorithms since it
        only happens when the lists are fully sorted, which is why they are  not the highest.
        So I believe that on average it will likely be O(n^2) more than it is O(n).
        Next, I believe shell sort is the third fastest. Like the previous three algorithms, it
        has a worst case time complexity of O(n^2), but it has a best case time complexity of
        O(nlog2n). The reason it is higher than insertion and bubble sort, despite having
        an identical worse cast and a slower best case is because of my previous belief that
        insertion and bubble sort will be more likely to have a O(n^2) complexity. Because of that
        looking at the worst case for shell sort it will give a similar run time to bubble and
        insertion. Then, looking at shell's best case of O(nlog^2n) is faster than O(n^2), so
        I believe that most of the time in shell sort's run time will be less than or equal to
        the runtimes of insertion and bubble sort, which is why I ranked it above bubble and
        insertion sort. Next, I believe that quick sort is the next fastest. It's worst case is
        O(n^2) and its best case is O(nlog n). For similar logic I used for shell sort. I think its
        runtime will be less than or equal to that of insertion and bubble sort, since O(n^2) is
        equal to O(n^2) and O(nlog n) is faster than O(n^2). The reason I believe it will be faster
        than shell sort is due to their worst and best case time complexities. At their worst
        both of them have a O(n^2) time complexity so, they will have similar runtimes at least.
        Then looking at their best cases, O(n log n) for quick sort is faster than O(nlog^2n)
        for shell sort, so at their best quick sort is faster. With that in mind, I think that
        quick sort will at the very leave have a similar runtime to shell sort, but be faster
        because its best case is faster than shell's best case. Finally, I believe that merge
        sort is the fastest. This is becuase its worst and best case is O(nlogn) so it will
        always have that time complexity no matter the array or the order of its contents.
        So, when comparing it to all previous ones, which have a time complexity of O(n^2)
        in the worst case, it is faster in the worst case than all of them. Then compared to
        quick sort, in the best case they will have a similar run time. So, it will have a
        better run time than all of them in the worst case, and a runtime equal to or less than
        quick sort. So that is why I ranked merge sort as the fastest.
