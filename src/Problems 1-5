Problem 1 Mergesort: List1: [1, 2, 3, 6], List2:[-3, 0, 6, 7], and Result: [] (size of 8)

                Compare 1 from List1 and -3 from List2, -3 is less than 1 so its added to Result.
                Result afterwards is: [-3].
            After the first iteration Result: [-3].

                Compare 1 from List1 and 0 from List2, 0 is less than 1 so its added to Result.
                Result afterwards is: [-3, 0].
            After the second iteration Result: [-3, 0].

                Compare 1 from List1 and 6 from List2, 1 is less than 6 so its added to Result.
                Result afterwards is: [-3, 0, 1].
            After the third iteration Result: [-3, 0, 1].

                Compare 2 from List1 and 6 from List2, 2 is less than 6 so it is added to Result.
                Result afterwards is: [-3, 0, 1, 2].
            After the fourth iteration Result: [-3, 0, 1, 2].

                Compare 3 from List1 and 6 from List2, 3 is less than 6 so it is added to Result.
                Result afterwards is: [-3, 0, 1, 2, 3].
            After the fifth iteration Result: [-3, 0, 1, 2, 3].

                Compare 6 from List1 and 6 from List2, 6 is equal to 6





Problem 2 Insertion Sort: List: [-21, 5, 7, -10, 61, 8, 3, 10]

                          Assume value at index 0, -21, is already sorted.
                          Compare 5 and -21, 5 is greater than -21 so no swap is done.
                          Since no swap is done and we assume -21 is sorted than that means
                          -21 and 5 are in sorted order.
          After first iteration: List: [-21, 5, 7, -10, 61, 8, 3, 10].


                          Compare 7 and 5, 7 is greater than 5 so no swap is done.
                          Since we know -21 and 5 are in sorted order and that 7 does
                          not get swapped with 5, we know it is also in sorted order
                          compared to -21 and 5, which is why is is not compared to -21.
          After second iteration: List [-21, 5, 7, -10, 61, 8, 3, 10].

                          Compare -10 and 7, -10 is less than 7 so swap -10 and 7.
                          After that the list is: [-21, 5, -10, 7, 61, 8, 3, 10].

                          Compare -10 and 5, -10 is less than 5 so swap -10 and 5.
                          After than the list is: [-21, -10, 5, 7, 61, 8, 3, 10].

                          Compare -10 and -21, -10 is greater than -21 so no swap is done.
                          Since -21 is already in sorted position and -10 does not swap with it
                          -10 is now in ordered position.
          After third iteration: List [-21, -10, 5, 7, 61, 8, 3, 10]

                          Compare 61 and 7, 61 is greater than 7 so no swap is done.
                          Since 7 is already in ordered position compared to the previous elements
                          and no swaps are done with 61, that means 61 is also in ordered position.
          After fourth iteration: List [-21, -10, 5, 7, 61, 8, 3, 10]

                          Compare 8 and 61, 8 is less than 61 so swap 8 and 61.
                          After that the list is: [-21, -10, 5, 7, 8, 61, 3, 10].

                          Compare 8 and 7, 8 is greater than 7 so no swap is done.
                          Since 7 is already in ordered position compared to the previous elements
                          and no swap is done with 8, that means 8 is in ordered position.
          After fifth iteration: List [-21, -10, 5, 7, 8, 61, 3, 10]

                          Compare 3 and 61, 3 is less than 61 so swap 3 and 61.
                          After that the list is: [-21, -10, 5, 7, 8, 3, 61, 10]

                          Compare 3 and 8, 3 is less than 8 so swap 3 and 8.
                          After that the list is: [-21, -10, 5, 7, 3, 8, 61, 10]

                          Compare 3 and 7, 3 is less than 7 so swap 3 and 7.
                          After that the list is: [-21, -10, 5, 3, 7, 8, 61, 10].

                          Compare 3 and 5, 3 is less than 5 so swap 3 and 5.
                          After that the list is: [-21, -10, 3, 5, 7, 8, 61, 10].

                          Compare 3 and -10, 3 is greater than -10 so no swap is done.
                          Since -10 is already in ordered position compared to the previous
                          elements, 3 is also now in ordered position.
          After sixth iteration: List [-21, -10, 3, 5, 7, 8, 61, 10].

                          Compare 10 and 61, 10 is less than 61, so swap 10 and 61.
                          After that the list is: [-21, -10, 3, 5, 7, 8, 10, 61]

                          Compare 10 and 8, 10 is greater than 8 so no swap.
                          Since 8 is already in ordered position compared to the previous elements
                          that means 10 is now also in ordered position.
          After seventh iteration: List [-21, -10, 3, 5, 7, 8, 10, 61]

                          Compare 61 and 10, 61 is greater than 10 so no swap.
                          Since 10 is already in sorted position compared to the previous
                          elements, that means 61 is now also in ordered position.
          After eighth iteration: List [-21, -10, 3, 5, 7, 8, 10, 61]
          The list is fully sorted.

Problem 3 Quicksort: List: [-5, 4, 2, 619, 11, 5, 620, -3]




Problem 4 Shell Sort: List: [5, 10, 60, 0, -1, 34, 6, 10]

            Gap= List.length /2, which is 8/2 = 4.
            So this means there are 4 interleaves this iteration made from List.
            Interleave1: [5,-1], Interleave2: [10,34], Interleave3: [60,6] and Interleave4: [0,10].
            Each interleave contains one element and every element the gap distance away from it.

            Compare 5 and -1 in Interleave1, 5 is less than -1, so swap 5 and -1.
            After that Interleave1: [-1,5]

            Compare 10 and 34 in Interleave2, 34 is greater than 10, so no swap occurs.

            Compare 60 and 6 in Interleave3, 6 is less than 60, so swap 6 and 60.
            After that Interleave3: [6, 60]

            Compare 0 and 10 in Interleave3, 10 is greater than 0 so no swap occurs.
        After one iteration List: [-1, 10, 6, 0, 5, 34, 60, 10]

            Gap= Gap/2 so 4/2 = 2
            So there will be 2 interleaves.
            Interleave1: [-1, 6, 5, 60] and Interleave2: [10, 0, 34, 10]

            Compare -1 and 6 in Interleave1, 6 is greater than -1 so no swap.

            Compare 6 and 5 in Interleave1, 5 is less than 6 so swap 5 and 6.
            After that Interleave1: [-1, 5, 6, 60]
            Compare -1 and 5 in Interleave1, 5 is greater than -1 so no swap.

            Compare 6 and 60 in Interleave1, 60 is greater than 6 so no swap.

            Compare 10 and 0 in Interleave2, 0 is less than 10 so swap 0 and 10.
            After that Interleave2: [0, 10, 34, 10].

            Compare 10, the first one and 34 in Interleave2, 34 is greater than 10 so no swap.
            Compare 34 and 10, the last one, 10 is less than 34 so swap 10 and 34.
            After that Interleave2: [0, 10, 10, 34].
            Compare 10 and 10, 10 is not less than 10, so no swap.
        After second iteration List: [-1, 0, 6, 10, 5, 10, 60, 34]

            Gap = Gap/2 so 2/2=1.

            Compare 0 and -1, 0 is greater than -1 so no swap.

            Compare 6 and 0, 6 is greater than 0 so no swap.

            Compare 10 and 6, 10 is greater than 6 so no swap.

            Compare 5 and 10, 5 is less than 10 so swap 5 and 10.
            List after: [-1, 0, 6, 5, 10, 10, 60, 34].
            Compare 5 and 6, 5 is less than 6 so swap 5 and 6.
            List after: [-1, 0, 5, 6, 10, 10, 60, 34].
            Compare 5 and 0, 5 is greater than 0 so no swap.

            Compare 10 and 10, 10 is not less than 10 so no swap.

            Compare 60 and 10, 60 is greater than 10 so no swap.

            Compare 34 and 60, 34 is less than 60 so swap 34 and 60.
            List after: [-1, 0, 5, 6, 10, 10, 34, 60]
            Compare 34 and 10, 34 is greater than 10 so no swap.

            Compare 60 and 34, 60 is greater than 34 so no swap.
        After third iteration List: [-1, 0, 5, 6, 10, 10, 34, 60]
        The list if fully sorted.

Problem 5:

        My ranking of the sorting algorithms is:
        (1 fastest to 5 slowest)
        1. Merge Sort
        2. Quick Sort
        3. Shell Sort
        4. Insertion Sort and Bubble Sort tied
        5. Selection sort

        The reason I ranked selection sort last is because no matter the input size
        or order it will always do two passes of the array so it will always be O(n^2).
        So since it will always be O(n^2) no matter what the array is I think it will consistently
        have the longest runtime compared to all the other sorting methods. Then the reason I
        predicted a tie for insertion and bubble sort is because both of them have a worst
        case time complexity of O(n^2), and a best case time complexity of O(n). Since, their
        worst and best case time complexities are the same, I think that insertion and bubble
        sort will have very similar run times to each other, which is why I believe that both
        of them are tied on the ranking. The reason I think that both of them are ranked higher
        than selection sort is because in their best case they are O(n), which is faster compared
        to selection sort's best case of O(n^2). So, with possibility of the best case in mind,
        I think that insertion and bubble sort will do better than selection sort. Even so the
        best case is not always likely to happen, compared to the other algorithms since it
        only happens when the lists are fully sorted, which is why they are  not the highest.
        So I believe that on average it will likely be O(n^2) more than it is O(n).
        Next, I believe shell sort is the third fastest. Like the previous three algorithms, it
        has a worst case time complexity of O(n^2), but it has a best case time complexity of
        O(nlog2n). The reason it is higher than insertion and bubble sort, despite having
        an identical worse cast and a slower best case is because of my previous belief that
        insertion and bubble sort will be more likely to have a O(n^2) complexity. Because of that
        looking at the worst case for shell sort it will give a similar run time to bubble and
        insertion. Then, looking at shell's best case of O(nlog^2n) is faster than O(n^2), so
        I believe that most of the time in shell sort's run time will be less than or equal to
        the runtimes of insertion and bubble sort, which is why I ranked it above bubble and
        insertion sort. Next, I believe that quick sort is the next fastest. It's worst case is
        O(n^2) and its best case is O(nlog n). For similar logic I used for shell sort. I think its
        runtime will be less than or equal to that of insertion and bubble sort, since O(n^2) is
        equal to O(n^2) and O(nlog n) is faster than O(n^2). The reason I believe it will be faster
        than shell sort is due to their worst and best case time complexities. At their worst
        both of them have a O(n^2) time complexity so, they will have similar runtimes at least.
        Then looking at their best cases, O(n log n) for quick sort is faster than O(nlog^2n)
        for shell sort, so at their best quick sort is faster. With that in mind, I think that
        quick sort will at the very leave have a similar runtime to shell sort, but be faster
        because its best case is faster than shell's best case. Finally, I believe that merge
        sort is the fastest. This is becuase its worst and best case is O(nlogn) so it will
        always have that time complexity no matter the array or the order of its contents.
        So, when comparing it to all previous ones, which have a time complexity of O(n^2)
        in the worst case, it is faster in the worst case than all of them. Then compared to
        quick sort, in the best case they will have a similar run time. So, it will have a
        better run time than all of them in the worst case, and a runtime equal to or less than
        quick sort. So that is why I ranked merge sort as the fastest.
